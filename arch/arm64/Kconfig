config ARM64
	def_bool y
        select ARCH_WANT_FRAME_POINTERS
	select FUNCTION_ALIGNMENT_4B
	select HAVE_ARCH_VMAP_STACK
	select 64BIT
	select HAVE_EFFICIENT_UNALIGNED_ACCESS
	select ARM_AMBA

choice
	prompt "Platform"
	default QEMU
	help
	  Select the platform you are building for.

config QEMU
	bool "QEMU"
	help
	  Platform for Qemu

config RASPI4B
	bool "Raspberry Pi 4B"
	help
	  Platform for Raspberry Pi 4B

endchoice



config BROKEN_GAS_INST
	def_bool !$(as-instr,1:\n.inst 0\n.rept . - 1b\n\nnop\n.endr\n)


menu "Arm64 architecture options"

choice
	prompt "Endianness"
	default CPU_LITTLE_ENDIAN
	help
	  Select the endianness of data accesses performed by the CPU. Userspace
	  applications will need to be compiled and linked for the endianness
	  that is selected here.

config CPU_LITTLE_ENDIAN
	bool "Build little-endian kernel"
	help
	  Say Y if you plan on running a kernel with a little-endian userspace.
	  This is usually the case for distributions targeting arm64.

endchoice


config BROKEN_GAS_INST
	def_bool !$(as-instr,1:\n.inst 0\n.rept . - 1b\n\nnop\n.endr\n)

menu "ARMv8.2 architectural features"
config AS_HAS_ARMV8_2
	def_bool $(cc-option,-Wa$(comma)-march=armv8.2-a)

endmenu # ARMv8.2 architectural features

menu "ARMv8.3 architectural features"

config AS_HAS_ARMV8_3
	def_bool $(cc-option,-Wa$(comma)-march=armv8.3-a)
endmenu # ARMv8.3 architectural features

menu "ARMv8.4 architectural features"

config AS_HAS_ARMV8_4
	def_bool $(cc-option,-Wa$(comma)-march=armv8.4-a)

endmenu # ARMv8.4 architectural features


menu "ARMv8.5 architectural features"

config AS_HAS_ARMV8_5
	def_bool $(cc-option,-Wa$(comma)-march=armv8.5-a)

endmenu # ARMv8.5 architectural features

menu "ARM errata workarounds via the alternatives framework"

config ARM64_ERRATUM_843419
	bool "Cortex-A53: 843419: A load or store might access an incorrect address"
	default y
	help
	  This option links the kernel with '--fix-cortex-a53-843419' and
	  enables PLT support to replace certain ADRP instructions, which can
	  cause subsequent memory accesses to use an incorrect address on
	  Cortex-A53 parts up to r0p4.

	  If unsure, say Y.

config ARM64_LD_HAS_FIX_ERRATUM_843419
	def_bool $(ld-option,--fix-cortex-a53-843419)


config FUJITSU_ERRATUM_010001
	bool "Fujitsu-A64FX erratum E#010001: Undefined fault may occur wrongly"
	default y
	help
	  This option adds a workaround for Fujitsu-A64FX erratum E#010001.
	  On some variants of the Fujitsu-A64FX cores ver(1.0, 1.1), memory
	  accesses may cause undefined fault (Data abort, DFSC=0b111111).
	  This fault occurs under a specific hardware condition when a
	  load/store instruction performs an address translation using:
	  case-1  TTBR0_EL1 with TCR_EL1.NFD0 == 1.
	  case-2  TTBR0_EL2 with TCR_EL2.NFD0 == 1.
	  case-3  TTBR1_EL1 with TCR_EL1.NFD1 == 1.
	  case-4  TTBR1_EL2 with TCR_EL2.NFD1 == 1.

	  The workaround is to ensure these bits are clear in TCR_ELx.
	  The workaround only affects the Fujitsu-A64FX.

	  If unsure, say Y.

 config ARM64_ERRATUM_845719
          bool "Cortex-A53: 845719: a load might read incorrect data"
          depends on COMPAT
          default y
          help
            This option adds an alternative code sequence to work around ARM
            erratum 845719 on Cortex-A53 parts up to r0p4.

            When running a compat (AArch32) userspace on an affected Cortex-A53
            part, a load at EL0 from a virtual address that matches the bottom 32
            bits of the virtual address used by a recent load at (AArch64) EL1
            might return incorrect data.

	    The workaround is to write the contextidr_el1 register on exception
            return to a 32-bit task.
            Please note that this does not necessarily enable the workaround,
            as it depends on the alternative framework, which will only patch
            the kernel if an affected CPU is detected.
            If unsure, say Y.

endmenu # ARM errata workarounds via the alternatives framework

menuconfig COMPAT
          bool "Kernel support for 32-bit EL0"
          depends on ARM64_4K_PAGES || EXPERT
          #select HAVE_UID16
	  #select OLD_SIGSUSPEND3
          #select COMPAT_OLD_SIGACTION
          help
            This option enables support for a 32-bit EL0 running under a 64-bit
            kernel at EL1. AArch32-specific components such as system calls,
            the user helper functions, VFP support and the ptrace interface are
            handled appropriately by the kernel.

	    If you use a page size other than 4KB (i.e, 16KB or 64KB), please
	    be aware that you will only be able to execute AArch32 binaries that
	    were compiled with page size aligned segments.
            If you want to execute 32-bit userspace applications, say Y.

menu "ARM64 Mem Management options"

choice
	prompt "Page size"
	default ARM64_4K_PAGES
	help
	  Page size (translation granule) configuration.

config ARM64_4K_PAGES
	bool "4KB"
	select HAVE_PAGE_SIZE_4KB
	help
	  This feature enables 4KB pages support.

config ARM64_16K_PAGES
	bool "16KB"
	select HAVE_PAGE_SIZE_16KB
	help
	  The system will use 16KB pages support. AArch32 emulation
	  requires applications compiled with 16K (or a multiple of 16K)
	  aligned segments.

config ARM64_64K_PAGES
	bool "64KB"
	select HAVE_PAGE_SIZE_64KB
	help
	  This feature enables 64KB pages support (4KB by default)
	  allowing only two levels of page tables and faster TLB
	  look-up. AArch32 emulation requires applications compiled
	  with 64K aligned segments.
endchoice


choice
	prompt "Virtual address space size"
	default ARM64_VA_BITS_48
	help
	  Allows choosing one of multiple possible virtual address
	  space sizes. The level of translation table is determined by
	  a combination of page size and virtual address space size.

config ARM64_VA_BITS_36
	bool "36-bit" if EXPERT
	depends on PAGE_SIZE_16KB

config ARM64_VA_BITS_39
	bool "39-bit"
	depends on PAGE_SIZE_4KB

config ARM64_VA_BITS_42
	bool "42-bit"
	depends on PAGE_SIZE_64KB

config ARM64_VA_BITS_47
	bool "47-bit"
	depends on PAGE_SIZE_16KB

config ARM64_VA_BITS_48
	bool "48-bit"

endchoice

config ARM64_VA_BITS
	int
	default 36 if ARM64_VA_BITS_36
	default 39 if ARM64_VA_BITS_39
	default 42 if ARM64_VA_BITS_42
	default 47 if ARM64_VA_BITS_47
	default 48 if ARM64_VA_BITS_48

choice
	prompt "Physical address space size"
	default ARM64_PA_BITS_48
	help
	  Choose the maximum physical address range that the kernel will
	  support.

config ARM64_PA_BITS_48
	bool "48-bit"
	help 
	  This feature enables 48-bit physical address space support.

config ARM64_PA_BITS_52
	bool "52-bit"
	depends on ARM64_64K_PAGES
	help
	  Enable support for a 52-bit physical address space, introduced as
	  part of the ARMv8.2-LPA extension.

	  With this enabled, the kernel will also continue to work on CPUs that
	  do not support ARMv8.2-LPA, but with some added memory overhead (and
	  minor performance overhead).

endchoice

config ARM64_PA_BITS
	int
	default 48 if ARM64_PA_BITS_48
	default 52 if ARM64_PA_BITS_52

endmenu # ARM64 Mem Management options

config RELOCATABLE
	bool "Build a relocatable kernel image" if EXPERT
	select ARCH_HAS_RELR
	default y
	help
	  This builds the kernel as a Position Independent Executable (PIE),
	  which retains all relocation metadata required to relocate the
	  kernel binary at runtime to a different virtual address than the
	  address it was linked at.
	  Since AArch64 uses the RELA relocation format, this requires a

endmenu # ARM64 architecture options
